模拟试题二
 
  
一、是非题(下列各题，你认为正确的，请在题干的括号内打“√”，错的打“×”。每题1分,共5分) 
1、算符优先关系表不一定存在对应的优先函数。 

2、数组元素的地址计算与数组的存储方式有关。

3、仅考虑一个基本块，不能确定一个赋值是否真是无用的。

4、每个文法都能改写为LL(1)文法。

5、对于数据空间的存贮分配，FORTRAN采用动态贮存分配策略。

二、填空题(每题2分，共20分) 

1、从功能上说，程序语言的语句大体可分为_______语句和______语句两大类。 

2、扫描器的任务是从________中识别出一个个_______。 

3、所谓最右推导是指：_______。 

4、语法分析最常用的两类方法是________和_________分析法。 

5、一个上下文无关文法所含四个组成部分是_______________。 

6、所谓语法制导翻译方法是_____________________。 

7、符号表中的信息栏中登记了每个名字的有关的性质，如_________等等。 

8、一个过程相应的DISPLAY表的内容为________。 

9、常用的两种动态存贮分配办法是_____动态分配和_____动态分配。 

10、产生式是用于定义_____的一种书写规则。 

三、名词解释(每题2分，共10分) 

1、遍 

2、无环路有向图(DAG) 

3、语法分析 

4、短语 

5、后缀式

四、简述题(每题4分，共24分) 

1、考虑下面程序 

　　 ………… 

　　 Var a：integer； 

　　 Procedure S(X)； 

　　　 Var X：integer； 

　　　 Begin 

　　　　 a：＝a＋1； 

　　　　 X：＝a＋X 

　　　 End； 

　　 Begin 

　　　　 a：＝5； 

　　　　 S(a)； 

　　　　 Print(a) 

　　 End． 

试问：若参数传递方式分别采取传名和传值时，程序执行后输出a的值是什么？ 

2、画出Pascal中实数(不带正负号，可带指数部分)的状态转换图。 

3、写出表达式(a＋b*c)/(a＋b)－d的逆波兰表示及三元式序列。 

4、已知文法G(S) 

　　 S→a|∧|(T) 

　　 T→T，S|S 

　　 写出句子((a，a)，a)的规范归约过程及每一步的句柄。 

5、何谓优化？按所涉及的程序范围可分为哪几级优化？ 

6、目标代码有哪几种形式？生成目标代码时通常应考虑哪几个问题？ 


五、计算题(共41分) 

1、写一个文法，使其语言是奇数集，且每个奇数不以0开头。(5分) 

2、设文法G(S)： 

　　 S→(L)|a S|a 

　　 L→L，S|S 

　　 (1)消除左递归和回溯； 

　　 (2)计算每个非终结符的FIRST和FOLLOW； 

　　 (3)构造预测分析表。 

3、While　a＞0 ∨b＜0　do 

　　 Begin 

　　　　 X：＝X＋1； 

　　　　 if a＞0 then a：＝a－1 

　　　　　　　　 else b：＝b＋1 

　　 End； 

　　 翻译成四元式序列。(7分) 

4、已知文法G(E) 

　　 E→T|E＋T 

　　 T→F|T *F 

　　 F→(E)|i 

　　 (1)给出句型(T *F＋i)的最右推导及画出语法树； 

　　 (2)给出句型(T *F＋i)的短语、素短语。(7分) 

5、设布尔表达式的文法为 

　　 E →E(1)∨E(2) 

　　 E →E(1)∧E(2) 

　　 E →i 

　　 假定它们将用于条件控制语句中，请 

　　 (1)改写文法，使之适合进行语法制导翻译和实现回填； 

　　 (2)写出改写后的短个产生式的语义动作。(6分) 

6、设有基本块 

　　 T1：＝2 

　　 T2：＝10/T 

　　 T3：＝S－R 

　　 T4：＝S＋R 

　　 A：＝T2 *T4 

　　 B：A 

　　 T5：＝S＋R 

　　 T6：＝T3 *T5 

　　 B：＝T6 

　　 (1)画出DAG图； 

　　 (2)假设基本块出口时只有A，B还被引用，请写出优化后的四元序列。(6分) 



  

参考答案： 

一、√ √ √ × ×

二、 1 执行性、 说明性 2、 源程序、 单词符号 3、 任何一步αβ都是对α中最右非终结符进行替换的 4 自上而下、 自下而上 5、 一组终结符号，一组非终结符号、一个开始符号、一组产生式 6、 为每个产生式配上一个翻译子程序，并在语法分析的同时执行这些子程序 7、 类型、种属、所占单元大小、地址 8、 现行活动记录地址和所有外层最新活动记录的地址 9、 栈式、 堆式 10、 语法范畴 

三、名词解释

1．遍－－指编译程序对源程序或中间代码程序从头到尾扫描一次。 

2．无环路有向图(DAG)－－如果有向图中任一通路都不是环路，则称庐有向图为 
无环路有向图，简称DAG。 

3．语法分析－－按文法的产生式识别输入的符号串是否为一个句子的分析过程。 

4．短语－－令G是一个文法。S划文法的开始符号，假定αβδ是文法G的一个句 
型，如果有SαAδ且AB，则称β是句型αβ相对非终结符A的短语。 

5．后缀式－－一种把运算量写在前面，把算符写在后面的表示表达式的方法。 

四、简述题

1、答：传名：a＝12　　　(2分) 
　　 　传值：a＝6　　　 (2分) 

3、答：逆波兰表示： 
　　　　　abc*＋ab＋/d－　　　　(2分) 
　　　 三元式序列： 
　　　　　 ① (*，b，c) 
　　　　　 ② (＋，a，①) 
　　　　　 ③ (＋，a，b) 
　　　　　 ④ (/，②，③) 
　　　　　 ⑤ (－，④，d)　　　　(2分) 

4、答： 句型　　　　　归约规则　　　　　句柄 
　　　((a，a)，a)　　S→a　　　　　　　a 
　　　((S，a)，a)　　T→S　　　　　　　S 
　　　((T，a)，a)　　S→a　　　　　　　a 
　　　((T，S)，a)　　T→T，S　　　　　 T，S 
　　　((S)，a)　　　 T→S　　　　　　　S 
　　　((T)，a)　　　 S→S(T)　　　 　　(T) 
　　　(S，a)　　　 　T→S　　　　　　　S 
　　　(T，a)　　　 　S→a　　　　　　　a 
　　　(T，S)　　　 　T→T，S　　　　　 T，S 
　　　(T)　　　 　　 S→(T)　　　　　　(T) 
　　 　S　　　　　　　　　　　　　　　　　　(4分) 

5、 答：优化：对程序进行各种等价变换，使得从变换后的程序出发，能产生更有效的目标代码。　　　　　　　　(2分) 
　　　　 三种级别：局部优化、循环优化、全局优化。　　(2分) 

6、 答：目标代码通常采用三种形式：机器语言，汇编语言，待装配机器语言模块。(2分) 
　　　　应着重考虑的问题： 
　　　　(1)如何使生成的目标代码较短； 
　　　　(2)如何充分利用寄存器，以减少访问内存次数； 
　　 　 (3)如何充分利用指仅系统的的特点。　　　　　 (2分)

五、计算题 

1、解：文法G(N)： 
　　　　　 N→AB|B 
　　　　　 A→AC|D 
　　　　　 B→1|3|5|7|9 
　　　　　 D→B|2|4|6|8 
　　　　　 C→0|D　　　　　(5分) 

2、解:(1) 
　　　　　 S→(L)|aS' 
　　　　　 S'→S|ε 
　　　　　 L→SL' 
　　　　　 L'→SL'|ε 
　　　评分细则：消除左递归2分，提公共因子2分。 

　　 　(2) 
　　　　　　 FIRST)S)＝{(，a}　　　　FOLLOW(S)＝{#，，，)} 
　　　　　　 FIRST(S')＝{，a,ε}　　FOLLOW(S')＝{#，，，)} 
　　　　　　 FIRST(L)＝{(，a}　　　　FOLLOW(L)＝{ )} 
　　　　　　 FIRST(L')＝{，，ε}　　FOLLOW(L'〕＝{ )} 

3、解： 
　　　(1) (j＞，a，0，5) 
　　　(2) (j，－，－，3) 
　　　(5) (＋，×，1，T1) 
　　　(6) (：＝，T1，－，×) 
　　　(7) (j≥，a，0，9) 
　　　(8) (j，－，－，12) 
　　　(9) (－，a，1，T2) 
　　　(10) (：＝，T2，－，a) 
　　　(11) (j，－，－，1) 
　　　(12) (＋，b，1， T3) 
　　　(13) (：＝，T3，－，b) 
　　　(14) (j，－，－，1) 
　　　(15) 
　　　　 评分细则：控制结构4分，其它3分。 

4、解：(1) 最右推导： 
　　　　　　　 ETF(E)(E＋T)(E＋F)(E＋i) 
　　　　　 　 (T＋i)(T*F＋i) 
　　　(2) 短语：(T*F＋i)，T*F＋i，T*F，i　　　　(2分) 
　　　　　　　　　 素短语：T*F,i 　　　　　　　　　　　　(1分) 

5、解：(1) E0→E(1) 
　　　　　 E→E0E(2) 
　　　　　 EA→E(1) 
　　　　　 E→EAE(2) 
　　　　　E→i　　　　　　　　　　　　　　　　　　(3分) 
　　 　 (2) E→E(1) 
　　　　　　{BACKPATCH(E(1)・FC，NXQ)； 
　　　　　　　　 E0・TC：＝E(1)・TC} 
　　　　　　E→E0E(2) 
　　　　　　　{E・FC：＝E(2)・FC； 
　　　　　　　　 E・TC：＝MERG(E0・TC，E(2)・TC)} 
　　　　　 EA→E(1) 
　　　　　　　{BACKPATCH(E(1)・TC，NXQ)； 
　　　　　　　　E0・FC：＝E(1)・FC} 
　　　　　 E→EAE(2) 
　　　　　　 {E・TC：＝E(2)・TC； 
　　　　　　　　E・FC：＝MERG(EA・FC，E(2)・FC} 
　　　　　 E→i 
　　　　　　　{E・TC：＝NXQ；E・FC：＝NXQ＋1； 
　　　　　　　　 GEN(jn2，entry(i)，－0)； 
　　　　　　　　 GEN(j，－，－，0)　　　　　　　　　(3分) 

6、解：(1)DAG： 
　　 (2) 优化后的四元式 
　　　　　　　 　　 T3：＝S－R 
　　　　　　　 　　 T4：＝S＋R 
　　　　　　　 　　 A：＝5*T4 
　　　　　　　 　　 B：＝T3＋T4　　　　　　　　　　　　(3分) 

 
 
